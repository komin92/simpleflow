#!/usr/bin/env python
from __future__ import print_function

import argparse
import re
import subprocess
import sys
from builtins import input, str  # noqa

from packaging.version import InvalidVersion, Version

VERSION_FILE = "simpleflow/__init__.py"
MAIN_BRANCH = "master"
CHANGELOG_FILE = 'CHANGELOG.md'


def color_msg(color, msg):
    colors = {
        "green": "\033[92m",
        "yellow": "\033[93m",
        "red": "\033[91m",
        "blue": "\033[94m"
    }
    if color in colors and sys.stdout.isatty():
        return colors[color] + msg + '\033[0m'
    else:
        return msg


def step(msg):
    print(color_msg("blue", "* {}".format(msg)))


def fail(message):
    """
    :param message: message to print
    :type message: string
    prints a message and exits
    """
    sys.stderr.write(color_msg("red", "Error: {}\nExiting...\n".format(message)))
    sys.exit(2)


def execute(command, ignore=False, log=False):
    """
    :param command: command to execute
    :type command: string
    :param ignore: if error should be ignored
    :type ignore: bool
    :param log: logs commands to stdout (default: False)
    :type log: bool
    :return : string command output
    Executes a command and returns the output
    """
    if log:
        print("execute: {}".format(command))
    pr = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

    (out, error) = pr.communicate()
    if pr.returncode != 0 and not ignore:
        fail("Error: executing '{}', {}".format(command, error))
    return out.decode("utf-8")


def current_branch():
    """
    Returns current branch name
    """
    for branch in execute("git branch --no-color").split("\n"):
        if branch.startswith("* "):
            return branch.split()[1]
    fail("Couldn't find current branch, please don't"
         " be in 'detached' state when running this.")


def on_main_branch():
    """
    Checks whether we're on main branch or not. If you're not on main
    branch, you're supposed to know what you do!
    """
    return current_branch() == MAIN_BRANCH


def current_version():
    # type: () -> Version
    with open(VERSION_FILE, "r") as f:
        version_line_regex = re.compile(r"""^__version__\s*=\s*['"](?P<version>.*?)['"]\s*$""")
        for line in f:
            m = version_line_regex.match(line)
            if m:
                return Version(m.group("version"))
    fail("Unable to find current version in {}".format(VERSION_FILE))


def increment_version(current):
    # type: (Version) -> Version
    epoch = current.epoch
    release = current.release
    pre = None
    post = None
    dev = None
    local = current.local
    if current.dev is not None:
        dev = current.dev + 1
    elif current.post is not None:
        post = current.post + 1
    elif current.pre is not None:
        pre = current.pre[:-1] + (current.pre[-1] + 1,)
    else:
        release = release[:-1] + (release[-1] + 1,)

    parts = []

    # Epoch
    if epoch != 0:
        parts.append("{0}!".format(epoch))

    # Release segment
    parts.append(".".join(str(x) for x in release))

    # Pre-release
    if pre is not None:
        parts.append("".join(str(x) for x in pre))

    # Post-release
    if post is not None:
        parts.append(".post{0}".format(post))

    # Development release
    if dev is not None:
        parts.append(".dev{0}".format(dev))

    # Local version segment
    if local is not None:
        parts.append("+{0}".format(local))

    return Version("".join(parts))


def generate_version_file(new_version, dry_run):
    # type: (Version, bool) -> None
    """
    Generates and modifies the simpleflow/__init__.py file
    """
    with open(VERSION_FILE, "r") as f:
        lines = f.readlines()

    def bump_version_line(line):
        if line.startswith("__version__"):
            return "__version__ = '{}'\n".format(new_version)
        return line

    lines = [bump_version_line(line) for line in lines]
    joined_lines = "".join(lines)

    if dry_run:
        print("Would write:\n{}".format(joined_lines))
    else:
        with open(VERSION_FILE, "w") as f:
            f.write(joined_lines)


def changelog_lines(from_tag):
    cmd = ["git", "log", "--pretty=format:- %b (%s)",
           "--merges", "{}..".format(from_tag)]
    out = subprocess.check_output(cmd)
    for line in out.splitlines():
        line = re.sub(r"\(Merge pull request (#\d+)[^)]+\)", r"(\1)", line)
        yield line


def proposed_changelog(from_tag, new_tag):
    return "\n{version}\n{underline}\n\n{content}\n".format(
        version=new_tag,
        underline="-" * len(new_tag),
        content="\n".join(list(changelog_lines(from_tag)))
    )


def write_changelog(content, new_tag):
    with open(CHANGELOG_FILE, "r") as f:
        current_changelog = f.readlines()

    # safeguard for not documenting the same tag twice
    if new_tag+"\n" in current_changelog:
        fail("The tag {} is already present in {}".format(new_tag, CHANGELOG_FILE))

    # detect where the first sub-title begins, it will be the first version
    # section ; we will introduce our new changelog here
    first_version_line_number = [
        idx for idx, line in enumerate(current_changelog)
        if line.startswith("---")
    ][0] - 2

    tmp_file = CHANGELOG_FILE
    with open(tmp_file, "w") as f:
        for idx, line in enumerate(current_changelog):
            if idx == first_version_line_number:
                f.write(content)
            f.write(line)


def generate_changelog(from_tag, to_tag, dry_run):
    proposed = proposed_changelog(from_tag, to_tag)
    print(proposed.replace("\n", "\n  "))
    if not dry_run:
        write_changelog(proposed, to_tag)
    return proposed


def release_tag(version_str, changes):
    """
    :param version_str: Version in string format
    :type version_str: string
    Commits and pushes the branch an tag
    """
    execute("git commit -a -m 'Bump version to {}'".format(version_str), log=True)
    annotation_message = "{}\n\nChangelog:\n{}".format(version_str, changes)
    # use "subprocess" directly to avoid escaping nightmares in annotation_message
    subprocess.check_output(["git", "tag", "-a", version_str, "-m", annotation_message])
    execute("git push origin HEAD", ignore=True, log=True)
    execute("git push origin {}".format(version_str), ignore=True, log=True)


def main():
    parser = argparse.ArgumentParser(description="Build and upload a new release.")
    parser.add_argument("--dry-run", "-n", action="store_true", help="don't actually do anything")
    parser.add_argument("--version", "-V", action="store_true", help="display version number")
    parser.add_argument("--new-version", help="new version number")
    args = parser.parse_args()
    if args.version:
        print("simpleflow {}".format(current_version()))
        return
    dry_run = args.dry_run

    step("Detect current/new version")
    current = current_version()
    print("Current version: {}".format(current))

    # decide a new version number to release
    new_version = ""
    if args.new_version:
        try:
            new_version = Version(args.new_version)
        except InvalidVersion:
            pass

    default_new_version = increment_version(current)
    while not new_version:
        new_version = input("New version to release [{}]: ".format(default_new_version))
        if not new_version:
            new_version = str(default_new_version)
        try:
            new_version = str(Version(new_version))
        except InvalidVersion as ex:
            print("{}; Should be PEP 440-compatible (for instance in the form: 1.2.3)".format(ex))

    # check if on main branch or not
    step("Check current branch")
    if not on_main_branch():
        print("WARNING!")
        print("  You're not on the main branch ({}).".format(MAIN_BRANCH))
        print("Please confirm you want to continue [y/N]", end=' ')
        answer = input()
        if not answer.lower().startswith("y"):
            fail("Will not continue as you're not on the main branch")

    # generate new version file
    step("Generate version file {}".format(VERSION_FILE))
    generate_version_file(new_version, dry_run)

    # generate changelog
    step("Generate {}".format(CHANGELOG_FILE))
    changes = generate_changelog(current, new_version, dry_run)

    # tag version
    step("Release tag")
    if not dry_run:
        release_tag(new_version, changes)

    # push package to pypi
    step("Generate and push package to pypi.python.org")
    execute("python setup.py bdist_wheel", log=True)
    wheel = "dist/simpleflow-{version}-py2.py3-none-any.whl".format(version=new_version)
    if not dry_run:
        execute("twine upload {}".format(wheel), log=True)


if __name__ == "__main__":
    main()
